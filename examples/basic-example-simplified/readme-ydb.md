# Создание базы 
Создайте serverless базу YDB согласно документации (либо используя terraform)

# Формирование ключа для доступа к YDB
В корневой директории необходимо сформировать ключ для доступа к базе.
Ключ будет сформирован в файле service_account_key_file.json

Запустите команду: (если Вы под windows - то лучше запускать из wsl - в противном случае Вам необходимо убрать слеши из команды)
```
yc iam key create \
--folder-id <идентификатор каталога> \
--service-account-name <имя сервисного аккаунта> \
--output service_account_key_file.json
```

### yc
Про установку и настройку yc прочитайте тут:

https://cloud.yandex.ru/docs/cli/quickstart

## Создание конфигурационного файла 
Создайте файл env.local в корневой директории.  
Скопируйте туда строку:  
YDB_SERVICE_ACCOUNT_KEY_FILE_CREDENTIALS=service_account_key_file.json  
(готовый пример файла уже приведен в данном проекте, в данном файле секреты отсутствуют)

# Настройка подключения к базе данных
Перейдите в консоль YDB, создайте базу данных и сверху справа будет кнопка "подключиться".
![img](https://raw.githubusercontent.com/Ulibka68/terrafrom-ydb-test2/contrubute-to-sdk/assets/1.png)
Нажмите на нее и заполните в файле env.local поля:  
DOCUMENT_API_ENDPOINT и  
DATABASENAME  

Либо просто скопируйте данную информацию из базы данных в web интерфейсе.
![img](https://raw.githubusercontent.com/Ulibka68/terrafrom-ydb-test2/contrubute-to-sdk/assets/2.png)

Попутно отмечу что базу данных можно удобно создавать с помощью terraform. Помимо базы данных Вы также можете создать такие ресурсы как каталог, сервисный account.

Прекрасный пример развертывания инфраструктуры на Yandex cloud сделал Виктор Кузенный, Вы можете найти его тут:
https://github.com/kvikuz/sls-web-application

P.S. **Обратите внимание!**  
Любой способ инициализации драйвера YDB требует наличия ENV переменных.
Если у Вас компьютер на windows, то Вам необходимо поставить один из пакетов мультиплатформенной поддержки ENV переменных. C этой целью я выбрал dotenv. Для его использования необходимо вызвать в главном файле функцию config.

# Улучшение старой системы описания таблиц

Если Вы уже пробовали YDB на nodejs, то заметили что предлагается написать, например, interface ISeason, class Season. Если Вы хотите описать опциональное поле, то декоратор надо писать так:
```js
@declareType({ optionalType: { item: { typeId: typePrim } } })
```

Для упрощения написания декораторов добавил два декоратора для описания обязательных и опциональных полей:  
declareTypePrim,  
declareTypeNull  

Теперь декораторы можно записать проще:
```js
  @declareTypePrim(TypePrim.UINT64)
  public id: number;

  @declareTypeNull(TypePrim.UTF8) // вместо @declareType({ optionalType: { item: { typeId: TypePrim.UTF8 } } })
  public title?: string;
```

Если раньше вместе с классом было необходимо написать интерфейс аналогичного содержания, то теперь я добавил generic тип ITableFromClass для получения типа-интерфейса для испольования в методе create. Теперь inreface не надо описывать самостоятельно.
```js
type ITMdb = ITableFromClass<Tmdb>;

// Метод create теперь выглядит вот так:
static create(inp: ITMdb) {
 return new Tmdb(inp);
}
```

Пример можно посмотреть в файле table_defs.ts

# Новая структура формирования описания таблиц 

Описывать структуру таблиц стало проще, но писать код для создания таблицы, добавления данных все равно еще несколько утомительно, поэтому я решил пойти дальше.

В одном из issue я предлагал реализовать кодогенерацию, но в итоге решил сделать в базовом классе возможность работы со всем спектром операций с таблицей - создание и удаление таблицы, вставка данных.

Текушая реализация позволяет с легкостью выполнять все вышеперечисленные действия:

1. создать/удалить таблицу согласно сформированному описанию таблицы
2. добавить одну строку с данными в таблицу, возможность использования опциональных полей.
3. добавить несколько записей в таблицу (все непереданные поля автоматически устанавливаются в null)
4. В SDK добавлена реализация команды bulk upsert

## Детали реализации
Оригинальная версия SDK разработана с учетом сохранения метаинформации о типах данных с использованием Reflect.metadata для свойств класса. Такой способ реализации подразумевает под собой вызов декоратора каждый раз при создании экземпляра класса либо при назначении нового значения свойству.

Я решил хранить метаданные, описывающие структуру таблицы в static свойстве (объекте) refMetaData. Такой подход позволят формировать метаданные только один раз перед использованием необходимого класса для таблицы. Реализация static в JS позволяет обращаться к static свойствам и методам наследующего класса из базового класса что позовлило внедрить в базовый класс TypedData все необходимые методы. 

### Создание объекта описания таблицы
Для использования новой системы описания таблицы YDB необходимо создать объект вида:

```js
const tdef = {
  id: { val: 0, pt: Pt.UINT64, opt: 'r', pk: true },
  title: { val: 'title', pt: Pt.UTF8, opt: 0 },
};
```
Сам объект представляет из себя структуру со следущими полями:

| |Описание|
|---|---|
|val|тип столбца YDB в JS. Если я правильно понял - то в JS возможно использование только следущих типов: number, string, BigInt.<br> JSON в YDB отображается на string в JS<br>Поскольку я не могу использовать фактические типы, то вместо типа необходимо задать любое значение<br>Например<br>0 - это number (вы можете поставить любое число, например 1.25)<br>'title' - это string|
|pt| PrimitiveTypeId - тип стобца в YDB - могут использоваться только определенные значения из enum PrimitiveTypeId (не все из них). Например нельзя указать тип INT8<br>Список типов, которые можно использовать для типизации столбца указан в документации [здесь](https://cloud.yandex.ru/docs/ydb/oss/public/develop/concepts/datatypes)<br>Вы можете использовать только те типы у которых в документации в столбце "Используется в качестве типа данных столбца" стоит да|
|opt|optional - нужно указывать либо 'r' - required либо 0.<br> При автоматическом  выводе типа из этого столбца извлекается информация о его типе - string или number|
|pk|primary key - это единственно не обязательное поле. Может принимать только одно значение - true.<br>Указание данного значения означает что поле входит в состав primary key таблицы.|

К сожалению вышеприведенный объект не может быть типизирован с помощью TS потому что он используется для автоматического выведения типов на основе этого объекта и при типизации
объекта пропадает возможность вывода типа.

Автоматический вывод типа выглядит следущим образом: 
```js
export type ITdef = ConvertStructToTypes<typeof tdef>;
```

### Вызов метода начальной инициализации класса initTableDef 
Для осуществления начальной начальной инициализации static объекта refMetaData класса с описанием таблицы YDB, необходимо обязательно вызывать метод initTableDef после описания класса. 

Вызов метода приводит к формированию необходимых метаданных для таблицы, формированию строк YQL запросов. Вызов этого метода необходим так как у каждого класса (таблицы) свой static объект refMetaData с описанием таблицы YDB.
```js
Tdef.initTableDef(Tdef, 'tmdb', databaseName, tdef);
```
Где:  

|Параметр|Описание   |
|---|---|
|Tdef |название класса в котором Вы описали таблицу|
|'tmdb'|название таблицы в базе данных YDB|
|databaseName|значение, ранее сохраненное в поле DATABASENAME (например "/ru-central1/b1gib03pgvqrrfvhl3kb/etnn9li53arnjigll14s")  
|tdef|объект, описывающий структуру таблицы|  

Дополнительно добавлю что вызов метода начальной инициализации можно добавить в сецию static класса. Такая возможность добавлена в ES2022 и уже поддержана в TS 4.4.4
([см. документацию MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Class_static_initialization_blocks))

### Итого:
Для формирования описания таблицы YDB в JS Вам необходимо выполнить 3 простых шага:
1. сформировать объект описания таблицы
2. написать строчку для формирования интерфейса
3. Вызвать static метод Вашего класса initTableDef
# Краткая информация по работе с SDK 

[В документации](https://cloud.yandex.ru/docs/ydb/ydb-sdk/)
Дается три понятия: **драйвер, клиент, сессия**.

## Драйвер
Драйвер YDB отвечает за взаимодействие приложения и YDB на транспортном уровне.
**Драйвер** должен существовать на всем протяжении жизненного цикла работы с YDB. Перед началом работы, необходимо инициализировать драйвер YDB.

В настоящем примере инициализация драйвера осуществляется функцией initYDBdriver. 

Для подключения к базе данных необходимо передать авторизационную информацию.
Это можно сделать несколькими способами.
Все возможные способы описаны в [исходном коде SDK](https://github.com/ydb-platform/ydb-nodejs-sdk/blob/master/src/parse-env-vars.ts#L74). Все способы подразумевает определение той или иной ENV переменной.

Обратите внимание что часть способов уже deprecated.
Я выбрал наиболее простой способ авторизации в YDB - создал файл с ключами и дал ссылку на него в env.local переменной  
```YDB_SERVICE_ACCOUNT_KEY_FILE_CREDENTIALS```

Создание файла с ключами описано в секции "Формирование ключа для доступа к YDB".

При создании драйвера также инициализируется логер.
Поскольку проект учебный - то в env.local добавлена переменная которая выводит максимум отладочной информации:  
YDB_SDK_LOGLEVEL=debug

## Клиент
Клиент отвечает за работу с сущностями YDB.

Самостоятельно клиент создавать не требуется (верно для nodejs SDK) - клиент создается самим драйвером в момент инициализации драйвера.

Драйвер инициализирует DiscoveryService, который опрашивает эндпойнты и связывает с каждым эндпойнтом фабрику сессий.

В рамках драйвера создаются **tableClient и schemeClient**, основная причина их разделения - это разные пулы сессий.

У каждого пула свой список используемых и свободных сессий, свои min/max-лимиты. При порождении новой сессии в рамках пула (сессия порождается, если все имеющиеся сессии заняты, но мы еще не вышли за пределы max-лимита на данный пул) по очереди обходятся все известные эндпойнты которые нам вернул DiscoveryService), т.е. запрос 1 на порождение сессии получит ее из эндпойнта1, а запрос 2 получит новую сессию из эндпойнта 2 - это простейший механизм балансировки сессий.

## Сессия
Сессия содержит информацию о выполняемых транзакциях и подготовленных запросах.

Получать сессию необходимо через клиента путем вызова метода<br>
 driver.tableClient.withSession  
либо  
 driver.tableClient.withSessionRetry

единственное отличие этих методов - это параметр maxRetries, который присутствует во втором методе.

При наличии параметра maxRetries служебный метод _withSession пробует исполнить запрос еще раз не более maxRetries раз с другой сессией.

Следует отметить, что автор SDK - Timur Sufiev использует первый способ - withSession.
При этом вызов самого запроса оборачивает в withRetries.

## Ретраи

При создании базы YDB (или потом) может быть установлено ограничение по пропускной способности, RU/с, которое ограничивает максимальное начисление платы за пользование serverless YDB за 1 секунду. В случае большой нагрузки на YDB при обработке запрос может прийти отказ из за превышения лимита начисления.

Поскольку это стандартная ситуация - то предусмотрены механизмы повторения отправленного запроса.  

withSessionRetry повторяет запрос только при получении двух ошибок: BadSession и SessionBusy.

Второй способ сделать повтор запроса - обернуть метод класса в декоратор  @retryable

Третий способ повторения запроса - использование функции-обертки withRetries.

withRetries формирует необходимые параметры и вызвает метод RetryStrategy.retry.

RetryStrategy.retry не пересоздает сессию в случае ошибок
RetryStrategy.retry делает ретраи на errors.Unavailable, errors.Aborted, errors.NotFound и errors.Overloaded 

В случае если Вы установили лимит на нагрузку БД (например установив ограничение RU/сек) то возможна перегрузка БД запросами. В этом случае будет формироваться исключение errors.Overloaded. В этом случае повтор происходит с увеличенным экспоненциальным таймаутом (см. исходники по RETRYABLE_ERRORS_SLOW).

# Таймауты 

В процессе обработки запросов Вы можете передавать в executeQuery ряд параметов, связанных с таймаутами. Часть параметров описана в kikimr тут:
[github](https://github.com/Ulibka68/ydb-nodejs-sdk/blob/master/kikimr/public/api/protos/ydb_operation.proto#L27)

